# -*- coding: utf-8 -*-
r"""
:mod:`tli` -- Tree level improvement.
=========================================

Calculate tree level improvements for lattice QCD observables in the
spirit of [1]_. Given an observable :math:`{\mathcal O}(a/L)`, one
defines the improved observable

.. math::

    {\mathcal O}_\mathrm{I}(a/L) = \frac {{\mathcal O}(a/L)} { 1 +
    \delta(a/L) }, \quad \delta(a/L) = \frac {{\mathcal O}(a/L) -
    {\mathcal O}(0)} {{\mathcal O}(0)} = \delta^{(0)}(a/L) + g_0^2
    \delta^{(1)}(a/L) + \ldots\,.

This package contains a function to calculate :math:`\delta(a/L)` for
given observables. In practially all cases, only the tree-level
approximation :math:`\mathcal O^{(0)}(a/L)` is known analytically, so
one will only be able to compute :math:`\delta^{(0)}`.


**References**

.. [1] G. de Divitiis *et al.*, *Universality and the approach to the
   continuum limit in lattice gauge theory*, Nucl.Phys. B *437*,
   447â€“470, 1995, ``[doi: 10.1016/0550-3213(94)00019-B]``.

"""

from math import exp, pi, sqrt, log
import scipy.optimize as sopt
import numpy as np

from observables import R1
ERR = 1e-10 # estimate of the round-off error for correlation fns.

############################################################
# Helper functions to calculate m_bare
############################################################

def min_x(z, LL = 0.195, NF = 0):
    r"""Function to minimize for finding :math:`x(z)` according to the
    formula given in append D of ``[arXiv:1001.4783]``. If you use
    e.g. scipy's newton method to minimize the resulting funciton, be
    careful to choose a 'good' starting value::

      >>> import scipy.optimize as sopt
      >>> import scipy.optimize as sopt
      >>> sopt.newton(min_x(z = 10), .7, tol=1e-15)
      0.5876680790030352
      >>> sopt.newton(min_x(z = 12), .7, tol=1e-15)
      0.5787751108231223
      >>> sopt.newton(min_x(z = 12), .1, tol=1e-15)
      RuntimeWarning: Tolerance of 0.00011 reached 
        warnings.warn(msg, RuntimeWarning)

    :param z: Input z value.
    :param LL: :math:`\Lambda L` as in ``[arXiv:1001.4783]``.
    :param NF: Number of quark flavors.
    :returns: Function. The value that minimizes that function is the
      sought-after value for :math:`x`.
    """
    B0 = 1. / (4 * pi)**2 * (11 - 2./3 * NF)
    B1 = 1. / (4 * pi)**4 * (102 - 38./3 * NF)
    D0 = 8. / (4 * pi)**2
    return lambda x : abs(LL/z - 2**(B1 / 2 / B0**2) * 
               x**(1 - B1 / B0 / D0) * 
               exp(-x**(-2. * B0 / D0)))

def pretty_print(val, err, extra_err_digits = 1):
    """Given a vaule with an error, generate a string of the form
    error(value)::

      >>> from tli import pretty_print
      >>> pretty_print(0.123, 0.011)
      '0.123(11)'
      >>> pretty_print(0.123, 0.011, 0)
      '0.12(1)'

    :param val: Float.
    :param err: Error on val.
    :param extra_err_digits: Display extra digits of the error.
    :returns: String.
    """
    if err == 0.0:
        assert val == 0.0
        return "0(0)"
    digits = 1 + int(abs(log(err, 10))) + extra_err_digits
    err = int(err * 10 ** digits + 0.5)
    if err == 10 and extra_err_digits != 1:
        err = 1
        digits -= 1
    return "{0:.{1}f}({2})".format(val, digits, err)



############################################################
#  Tree level improvement
############################################################

def tli(obs, args, Lrange, n_cut, lrange, x_val, z):
    """Calculate the tree level improvment of an observable. This is
    accomplished in two steps.

    1. Estimate the continuum limit of obs by performing two fits of
       the form :math:`a_0 + a_2 (a/L)^2 + a_3 (a/L)^3 + a_4\,
       (a/L)^4` (i.e. we assume obs to be :math:`O(a)`-improved) to
       data generated by applying obs to the values in Lrange, one
       fit using all values in Lrange, and one omitting the first
       n_cut points. The difference is then used as an estimate for
       the systematic error.

    2. Calculate :math:`\delta (a/L)` for the values of :math:`L/a`
       provided in lrange.

    A minimalistic example::

      >>> from tli import tli
      >>> tli, dtli, cl = tli(lambda L, x, z : 1. + 2./L**2, (), 
      ...                     range(50,100,2), 10, (10,14), 0, 0)
      >>> tli
      [0.019999999999999792, 0.010204081632652738]
      >>> dtli
      [1.0200135891298212e-10, 1.0102175402546249e-10]
      >>> cl
      1.0000000000000002

    :param obs: The observable (function).
    :param args: The observable is expected to have a call signature
      like ``obs(L, x_val, z, *args)``, where ``x`` is the x-value
      obtained using :class:`min_x`, ``L`` the number of lattice
      points in each direction and ``z`` the mass parameter.
    :param Lrange: A iterable giving the lattice resoultions that
      should be used in the fit to extract the continuum limit.
    :param n_cut: Number of data points to be omitted in a second fit
      to estimate the systematic error for the continuum limit.
    :param lragne: Values for :math:`(L/a)` for which to calculate the
      tree level improvement.
    :param x_val: Value for :math:`x` as in ``[arXiv:1001.4783]``.
    :param z: Mass parameter.
    :returns: Tuple ``(tli, d_cli, cl)`` with tree level improvement
      coefficients cl, errors on tli coefficients d_cli, and continuum
      limits cl. 
    """
    # make a list of the observable for various values of L
    # to extract the continuum limit
    f_list = [obs(L, x_val, z, *args) for L in Lrange]
    # error function for the fit
    efn = lambda p, x, y : y - p[0] - p[1]/x/x \
        - p[2]/x/x/x - p[3]/x/x/x/x
    # perform two fits to be able to estimate the error
    (cl1, p1, p2, p3), success = \
        sopt.leastsq(efn, [1,0,0,0], args = (Lrange, f_list))
    (cl2, p1, p2, p3), success = \
        sopt.leastsq(efn, [1,0,0,0], args = (Lrange[n_cut:],
                                           f_list[n_cut:]))
    cl, dcl = cl1, abs(cl1-cl2)
    if abs(cl) < 10*abs(dcl):
        print " ** WARNING,", obs.__name__, "seems to vanish as a/L -> 0"
        print " ** My estimate: {0} --> {1} as a/L --> 0".format(
            obs.__name__, pretty_print(cl, dcl))
        print " ** using delta = O(a/L) - O(0) for", obs.__name__
        print " ** for argument", args
        delta_fun = lambda x : x - cl
        d_delta_fun = lambda dO, O, de: dO + dcl
    else:
        delta_fun = lambda x : (x - cl) / cl
        d_delta_fun = lambda dO, O, de : \
            ((dO + dcl)/abs(O-cl) + dcl/abs(cl))*abs(de)\
            if O != cl else 0.0
    # the observable at lattice sizes given in lragne
    Obs = [obs(L, x_val, z, *args) for L in lrange]
    # the estimate error on the observables
    d_Obs = [abs(O * ERR) for O in Obs]
    # the tree level cut-off effects at those
    delta = [ delta_fun(O) for O in Obs]
    # the error on the cut-off effects
    d_delta = [ d_delta_fun(dO, O, de)
                for (dO, O, de) in zip(d_Obs, Obs, delta) ]
    return delta, d_delta, cl

if __name__ == "__main__":
    # Ls used for continuum limit
    Lrange = range(86,257,2)
    # Ls to produce TLI data for
    lrange = (20,24,32)
    # zs to be used
    zrange = (10.4,12.1,13.3)
    # these are the values for x by michele as reference
    xmichele = {10.4 : 0.585712, 12.1: 0.578382, 13.3: 0.573977}

    for z in zrange:
        print " * z =", z
        # this is my value for x 
        myx = sopt.newton(min_x(z), .7, tol=1e-15)
        # here, we compare, including a "goodness of fit"
        # the latter comes form checking how good 
        print "      my x:", myx, min_x(z)(myx)
        print "   michele:", xmichele[z], min_x(z)(xmichele[z])
        # choose here which one to use
        x = myx
        # x = xmichele[z]
        # get the tree level improvement
        delta, d_delta, cl = tli(R1, (0.0, 0.5), 
                                 Lrange, 17, lrange, x, z)
        # print continuum limit
        print "   -> c.l. =", cl
        # print tli
        for L, d, dd in zip(lrange, delta, d_delta):
            print "   ", L, pretty_print(d,dd)
